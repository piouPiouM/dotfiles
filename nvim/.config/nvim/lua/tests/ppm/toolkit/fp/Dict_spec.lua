local fp = require("ppm.toolkit.fp.function")
local pipe = fp.pipe

describe("Dict", function()
  local D = require("ppm.toolkit.fp.Dict")

  describe("metamethods", function()
    describe("__tostring()", function()
      it("should return the content of the dictionary", function()
        local actual = tostring(D.of({ "a", "b", "c" }))
        assert.are.equals('Dict({ { 1, "a" }, { 2, "b" }, { 3, "c" } })', actual)
      end)
    end)

    describe("__len()", function()
      it("should return the length of the dictionary", function()
        local actual = D.of({ a = "aa", b = "bb", c = "cc" })
        assert.are.equals(3, #actual)
      end)

      it("should return zero", function()
        local actual = D.of({})
        assert.are.equals(0, #actual)
      end)
    end)
  end)

  describe("constructors", function()
    describe("of()", function()
      it("should create a Dict of zero entry", function()
        local actual = D.of({})
        assert.are.same({}, actual._data)
      end)

      it("should create a Dict of zero entry when none argument is given", function()
        local actual = D.of()
        assert.are.same({}, actual._data)
      end)
    end)

    describe("zero()", function()
      it("should return an empty Dict", function()
        local actual = D.zero()
        assert.are.same(D.of({}), actual)
        assert.are.equals(0, #actual)
      end)
    end)
  end)

  describe("converters", function()
    describe("from_pairs()", function()
      it("should create a new Dict", function()
        local actual = D.from_pairs({ { "a", "aa" }, { "b", "bb" } })
        assert.are.same({ a = { "a", "aa" }, b = { "b", "bb" } }, actual._data)
      end)
    end)

    describe("to_pairs()", function()
      it("should return a list of tuples", function()
        local expected = { a = { "a", "aa" }, b = { "b", "bb" } }
        local actual = D.to_pairs(D.of({ a = "aa", b = "bb" }))
        assert.are.same(expected, actual)
      end)
    end)
  end)

  describe("utils", function()
    describe("copy()", function()
      it("should return a shallow copy of the given table", function()
        local actual = D.copy({ 1, "a", foo = 2 })
        local expected = D.of({ 1, "a", foo = 2 })
        assert.are.same(expected, actual)
        assert.are.not_equals(expected, actual)
      end)

      it("should return a shallow copy of the nested table", function()
        local actual = D.copy({ 1, "a", foo = { 2 }, { 3 } })
        local expected = D.of({ 1, "a", foo = { 2 }, { 3 } })
        assert.are.same(expected, actual)
        assert.are.not_equals(expected, actual)
      end)

      it("should return a new empty array", function()
        local actual = D.copy({})
        local expected = D.of({})
        assert.are.same(expected, actual)
        assert.are.not_equals(expected, actual)
      end)
    end)

    describe("pipeables", function()
      describe("filter()", function()
        it("should filter entries by keys, return a new Dict with only the numeric ones", function()
          local actual = pipe(
            D.of({ "a", b = "b", "c", d = "d" }),
            D.filter(function(key) return type(key) == "number" end)
          )
          assert.are.same(D.of({ "a", "c" }), actual)
        end)

        it("should filter entries by values, return a new Dict with 'a' and 'b'", function()
          local actual = pipe(
            D.of({ "a", b = "b", "c", d = "d" }),
            D.filter(function(_, value) return value == "a" or value == "b" end)
          )
          assert.are.same(D.of({ "a", b = "b" }), actual)
        end)
      end)
    end)
  end)
end)
